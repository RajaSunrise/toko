package handlers

import (
	"fmt"
	"log"
	"strings"
	"toko/internal/models"
	"toko/internal/services"

	"github.com/go-playground/validator/v10"
	"github.com/gofiber/fiber/v2"
)

// ProductHandler handles HTTP requests for products.
type ProductHandler struct {
	service  *services.ProductService
	validate *validator.Validate
}

// NewProductHandler creates a new ProductHandler.
func NewProductHandler(service *services.ProductService) *ProductHandler {
	return &ProductHandler{
		service:  service,
		validate: validator.New(),
	}
}

// RegisterRoutes registers the product routes with the Fiber app.
func (h *ProductHandler) RegisterRoutes(router fiber.Router) {
	productRoutes := router.Group("/products")
	productRoutes.Get("/", h.HandleGetProducts)
	productRoutes.Get("/:id", h.HandleGetProductByID)
	productRoutes.Post("/", h.HandleCreateProduct)
	productRoutes.Put("/:id", h.HandleUpdateProduct)
	productRoutes.Delete("/:id", h.HandleDeleteProduct)
}

// HandleGetProducts retrieves all products.
func (h *ProductHandler) HandleGetProducts(c *fiber.Ctx) error {
	products, err := h.service.GetAllProducts()
	if err != nil {
		log.Printf("Error getting all products: %v", err)
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"message": "Could not retrieve products",
			"error":   err.Error(),
		})
	}
	return c.JSON(products)
}

// HandleGetProductByID retrieves a single product by its ID.
func (h *ProductHandler) HandleGetProductByID(c *fiber.Ctx) error {
	productID := c.Params("id")
	product, err := h.service.GetProductByID(productID)
	if err != nil {
		log.Printf("Error getting product by ID %s: %v", productID, err)
		// Check if the error is because the product was not found
		if strings.Contains(err.Error(), "not found") { // More robust check
			return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
				"message": fmt.Sprintf("Product with ID %s not found", productID),
			})
		}
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"message": "Could not retrieve product",
			"error":   err.Error(),
		})
	}
	return c.JSON(product)
}

// HandleCreateProduct creates a new product.
func (h *ProductHandler) HandleCreateProduct(c *fiber.Ctx) error {
	var product models.Product
	if err := c.BodyParser(&product); err != nil {
		log.Printf("Error parsing request body: %v", err)
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"message": "Invalid request body",
			"error":   err.Error(),
		})
	}

	// Validate the product struct
	if err := h.validate.Struct(product); err != nil {
		// Handle validation errors
		validationErrors := err.(validator.ValidationErrors)
		errorMessages := make(map[string]string)
		for _, e := range validationErrors {
			errorMessages[e.Field()] = fmt.Sprintf("Field '%s' failed on the '%s' tag", e.Field(), e.Tag())
		}
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"message": "Validation failed",
			"errors":  errorMessages,
		})
	}

	err := h.service.CreateProduct(&product)
	if err != nil {
		log.Printf("Error creating product: %v", err)
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"message": "Could not create product",
			"error":   err.Error(),
		})
	}

	// Return the created product with its new ID (if generated by service/repo)
	// Using StatusCreated (201) is standard for successful POST requests
	return c.Status(fiber.StatusCreated).JSON(product)
}

// HandleUpdateProduct updates an existing product.
func (h *ProductHandler) HandleUpdateProduct(c *fiber.Ctx) error {
	productID := c.Params("id")
	var productUpdate models.Product

	if err := c.BodyParser(&productUpdate); err != nil {
		log.Printf("Error parsing request body: %v", err)
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"message": "Invalid request body",
			"error":   err.Error(),
		})
	}

	// Ensure the ID from the URL is used, not one from the request body
	productUpdate.ID = productID

	// Validate the product struct for update
	// Use h.validate.StructPartial if you only want to validate provided fields
	// For now, we assume all fields are required for update as per struct tags.
	if err := h.validate.Struct(productUpdate); err != nil {
		validationErrors := err.(validator.ValidationErrors)
		errorMessages := make(map[string]string)
		for _, e := range validationErrors {
			errorMessages[e.Field()] = fmt.Sprintf("Field '%s' failed on the '%s' tag", e.Field(), e.Tag())
		}
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"message": "Validation failed",
			"errors":  errorMessages,
		})
	}

	err := h.service.UpdateProduct(&productUpdate)
	if err != nil {
		log.Printf("Error updating product with ID %s: %v", productID, err)
		// Check if the error is because the product was not found
		if strings.Contains(err.Error(), "not found") { // More robust check
			return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
				"message": fmt.Sprintf("Product with ID %s not found", productID),
			})
		}
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"message": "Could not update product",
			"error":   err.Error(),
		})
	}

	// Return the updated product
	return c.JSON(productUpdate)
}

// HandleDeleteProduct deletes a product by its ID.
func (h *ProductHandler) HandleDeleteProduct(c *fiber.Ctx) error {
	productID := c.Params("id")

	err := h.service.DeleteProduct(productID)
	if err != nil {
		log.Printf("Error deleting product with ID %s: %v", productID, err)
		// Check if the error is because the product was not found
		if strings.Contains(err.Error(), "not found") { // More robust check
			return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
				"message": fmt.Sprintf("Product with ID %s not found", productID),
			})
		}
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"message": "Could not delete product",
			"error":   err.Error(),
		})
	}

	// Respond with a success message, usually with no content (204 No Content) or a confirmation message (200 OK)
	return c.Status(fiber.StatusOK).JSON(fiber.Map{
		"message": fmt.Sprintf("Product with ID %s deleted successfully", productID),
	})
}
