package handlers

import (
	"fmt"
	"log"
	"toko/internal/models"
	"toko/internal/services"

	"github.com/gofiber/fiber/v2"
)

// ProductHandler handles HTTP requests for products.
type ProductHandler struct {
	service *services.ProductService
}

// NewProductHandler creates a new ProductHandler.
func NewProductHandler(service *services.ProductService) *ProductHandler {
	return &ProductHandler{
		service: service,
	}
}

// RegisterRoutes registers the product routes with the Fiber app.
func (h *ProductHandler) RegisterRoutes(router fiber.Router) {
	productRoutes := router.Group("/products")
	productRoutes.Get("/", h.HandleGetProducts)
	productRoutes.Get("/:id", h.HandleGetProductByID)
	productRoutes.Post("/", h.HandleCreateProduct)
	productRoutes.Put("/:id", h.HandleUpdateProduct)
	productRoutes.Delete("/:id", h.HandleDeleteProduct)
}

// HandleGetProducts retrieves all products.
func (h *ProductHandler) HandleGetProducts(c *fiber.Ctx) error {
	products, err := h.service.GetAllProducts()
	if err != nil {
		log.Printf("Error getting all products: %v", err)
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"message": "Could not retrieve products",
			"error":   err.Error(),
		})
	}
	return c.JSON(products)
}

// HandleGetProductByID retrieves a single product by its ID.
func (h *ProductHandler) HandleGetProductByID(c *fiber.Ctx) error {
	productID := c.Params("id")
	product, err := h.service.GetProductByID(productID)
	if err != nil {
		log.Printf("Error getting product by ID %s: %v", productID, err)
		// Check if the error is because the product was not found
		if err.Error() == fmt.Sprintf("product with ID %s not found", productID) {
			return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
				"message": fmt.Sprintf("Product with ID %s not found", productID),
			})
		}
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"message": "Could not retrieve product",
			"error":   err.Error(),
		})
	}
	return c.JSON(product)
}

// HandleCreateProduct creates a new product.
func (h *ProductHandler) HandleCreateProduct(c *fiber.Ctx) error {
	var product models.Product
	if err := c.BodyParser(&product); err != nil {
		log.Printf("Error parsing request body: %v", err)
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"message": "Invalid request body",
			"error":   err.Error(),
		})
	}

	// Basic validation: Name and Price are required
	if product.Name == "" || product.Price <= 0 {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"message": "Product name and price are required and price must be positive.",
		})
	}

	err := h.service.CreateProduct(&product)
	if err != nil {
		log.Printf("Error creating product: %v", err)
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"message": "Could not create product",
			"error":   err.Error(),
		})
	}

	// Return the created product with its new ID (if generated by service/repo)
	// Using StatusCreated (201) is standard for successful POST requests
	return c.Status(fiber.StatusCreated).JSON(product)
}

// HandleUpdateProduct updates an existing product.
func (h *ProductHandler) HandleUpdateProduct(c *fiber.Ctx) error {
	productID := c.Params("id")
	var productUpdate models.Product

	if err := c.BodyParser(&productUpdate); err != nil {
		log.Printf("Error parsing request body: %v", err)
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"message": "Invalid request body",
			"error":   err.Error(),
		})
	}

	// Ensure the ID from the URL is used, not one from the request body
	productUpdate.ID = productID

	// Basic validation
	if productUpdate.Name == "" || productUpdate.Price <= 0 {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"message": "Product name and price are required and price must be positive.",
		})
	}

	err := h.service.UpdateProduct(&productUpdate)
	if err != nil {
		log.Printf("Error updating product with ID %s: %v", productID, err)
		// Check if the error is because the product was not found
		if err.Error() == fmt.Sprintf("product with ID %s not found for update", productID) {
			return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
				"message": fmt.Sprintf("Product with ID %s not found", productID),
			})
		}
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"message": "Could not update product",
			"error":   err.Error(),
		})
	}

	// Return the updated product
	return c.JSON(productUpdate)
}

// HandleDeleteProduct deletes a product by its ID.
func (h *ProductHandler) HandleDeleteProduct(c *fiber.Ctx) error {
	productID := c.Params("id")

	err := h.service.DeleteProduct(productID)
	if err != nil {
		log.Printf("Error deleting product with ID %s: %v", productID, err)
		// Check if the error is because the product was not found
		if err.Error() == fmt.Sprintf("product with ID %s not found for deletion", productID) {
			return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
				"message": fmt.Sprintf("Product with ID %s not found", productID),
			})
		}
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"message": "Could not delete product",
			"error":   err.Error(),
		})
	}

	// Respond with a success message, usually with no content (204 No Content) or a confirmation message (200 OK)
	return c.Status(fiber.StatusOK).JSON(fiber.Map{
		"message": fmt.Sprintf("Product with ID %s deleted successfully", productID),
	})
}
